document.addEventListener('DOMContentLoaded', () => {
  // DOM Element References
  const themeControls = document.getElementById('theme-controls');
  const alignmentControls = document.getElementById('alignment-controls');
  const downloadConfigBtn = document.getElementById('download-config-btn');
  const downloadStylesBtn = document.getElementById('download-styles-btn');
  const updateInterfaceBtn = document.getElementById('update-interface-btn');
  const addThemeBtn = document.getElementById('add-theme-btn');
  const newThemeNameInput = document.getElementById('new-theme-name');
  const colorHexInputs = document.querySelectorAll('.color-hex-input');
  const colorPickers = document.querySelectorAll('input[type="color"]');
  const uploadInstructions = document.getElementById('upload-instructions');

  // Themes object - mutable to allow adding/deleting themes
  const allThemes = {
    'soft-evergreen-theme': { name: 'Soft Evergreen', class: 'soft-evergreen-theme', colors: ['#e8f0ef', '#3f514b', '#6a9a8d', '#cedbd9'], isDefault: true },
    'desert-bloom-theme': { name: 'Desert Bloom', class: 'desert-bloom-theme', colors: ['#fcf8f3', '#5d4037', '#d17a7a', '#e5d5c9'], isDefault: true },
    'muted-clay-theme': { name: 'Muted Clay', class: 'muted-clay-theme', colors: ['#e7e0d9', '#4a4a4a', '#a38c82', '#d1c7c0'], isDefault: true },
    'stormy-sky-theme': { name: 'Stormy Sky', class: 'stormy-sky-theme', colors: ['#e9ecef', '#2c3e50', '#7b9ebc', '#c7d2da'], isDefault: true },
    'stone-grey-theme': { name: 'Stone Grey', class: 'stone-grey-theme', colors: ['#f5f5f5', '#424242', '#9e9e9e', '#e0e0e0'], isDefault: true },
    'soft-lavender-theme': { name: 'Soft Lavender', class: 'soft-lavender-theme', colors: ['#f7f3f9', '#544458', '#a08da6', '#e1dbe4'], isDefault: true },
    'gilded-iris-theme': { name: 'Gilded Iris', class: 'gilded-iris-theme', colors: ['#fdfaf3', '#4b422e', '#c5a76c', '#e9e2d3'], isDefault: true }
  };

  // State object to track user selections
  let state = {
    selectedTheme: 'soft-evergreen-theme',
    selectedAlignment: 'center'
  };

  // --- FUNCTIONS --- //

  function updateActiveControls() {
    document.querySelectorAll('.theme-option').forEach(opt => opt.classList.toggle('active', opt.dataset.theme === state.selectedTheme));
    document.querySelectorAll('.alignment-option').forEach(opt => opt.classList.toggle('active', opt.dataset.alignment === state.selectedAlignment));
  }

  function createConfigFile() {
    const configContent = `// Widget configuration file
// This file is generated by the Admin Dashboard.
const widgetConfig = {
  theme: '${state.selectedTheme}',
  alignment: '${state.selectedAlignment}'
};`;
    triggerDownload(configContent, 'config.js', 'text/javascript');
    downloadConfigBtn.classList.add('clicked');
  }

  function downloadStylesFile() {
      const cssContent = generateCssContent();
      triggerDownload(cssContent, 'styles.css', 'text/css');
      downloadStylesBtn.classList.add('clicked');
  }

  function downloadSettingsJsFile() {
      const settingsJsContent = generateSettingsJsContent();
      triggerDownload(settingsJsContent, 'settings.js', 'text/javascript');
      updateInterfaceBtn.classList.add('clicked');
  }

  function triggerDownload(content, fileName, mimeType) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function addThemeStyle(themeKey, colors) {
    const style = document.createElement('style');
    style.id = `style-${themeKey}`;
    style.innerHTML = `.${themeKey}{--primary-bg-color:${colors[0]};--primary-text-color:${colors[1]};--accent-color:${colors[2]};--secondary-bg-color:${colors[3]};}`;
    document.head.appendChild(style);
  }
  
  function showSaveAndUploadElements() {
      downloadStylesBtn.style.display = 'inline-block';
      updateInterfaceBtn.style.display = 'inline-block';
      uploadInstructions.style.display = 'block';
      downloadStylesBtn.classList.remove('clicked');
      updateInterfaceBtn.classList.remove('clicked');
  }

  function renderThemes() {
    themeControls.innerHTML = '';
    for (const themeKey in allThemes) {
      const theme = allThemes[themeKey];
      const option = document.createElement('div');
      option.className = 'theme-option';
      option.dataset.theme = theme.class;
      option.innerHTML = `<div class="color-swatch" style="background-color: ${theme.colors[0]};"></div><span>${theme.name}</span>${!theme.isDefault ? `<button class="delete-btn" data-theme-key="${themeKey}">×</button>` : ''}`;
      option.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-btn')) return;
        state.selectedTheme = option.dataset.theme;
        downloadConfigBtn.classList.remove('clicked');
        updateActiveControls();
      });
      themeControls.appendChild(option);
    }
    document.querySelectorAll('.delete-btn').forEach(btn => btn.addEventListener('click', deleteTheme));
    updateActiveControls();
  }

  function addNewTheme() {
    const themeName = newThemeNameInput.value.trim();
    if (!themeName) { alert('Please enter a theme name.'); return; }
    const themeKey = themeName.toLowerCase().replace(/\s+/g, '-') + '-theme';
    if (allThemes[themeKey]) { alert('A theme with this name already exists.'); return; }
    const colors = [
        document.getElementById('color-primary-bg').value,
        document.getElementById('color-primary-text').value,
        document.getElementById('color-accent').value,
        document.getElementById('color-secondary-bg').value
    ];
    allThemes[themeKey] = { name: themeName, class: themeKey, colors: colors, isDefault: false };
    addThemeStyle(themeKey, colors);
    renderThemes();
    newThemeNameInput.value = '';
    showSaveAndUploadElements();
  }

  function deleteTheme(event) {
    const themeKey = event.target.dataset.themeKey;
    if (allThemes[themeKey]) {
        const styleTag = document.getElementById(`style-${themeKey}`);
        if (styleTag) styleTag.remove();
        delete allThemes[themeKey];
        if (state.selectedTheme === themeKey) { state.selectedTheme = Object.keys(allThemes)[0]; }
        renderThemes();
        showSaveAndUploadElements();
    }
  }

  // --- EVENT LISTENERS & INITIALIZATION --- //

  downloadConfigBtn.addEventListener('click', createConfigFile);
  downloadStylesBtn.addEventListener('click', downloadStylesFile);
  updateInterfaceBtn.addEventListener('click', downloadSettingsJsFile);
  addThemeBtn.addEventListener('click', addNewTheme);
  
  alignmentControls.querySelectorAll('.alignment-option').forEach(option => {
    option.addEventListener('click', () => { 
        state.selectedAlignment = option.dataset.alignment; 
        downloadConfigBtn.classList.remove('clicked');
        updateActiveControls(); 
    });
  });
  
  colorPickers.forEach(picker => picker.addEventListener('input', (e) => { document.querySelector(`.color-hex-input[data-picker="${e.target.id}"]`).value = e.target.value; }));
  colorHexInputs.forEach(input => input.addEventListener('input', (e) => { document.getElementById(e.target.dataset.picker).value = e.target.value; }));

  Object.keys(allThemes).forEach(key => addThemeStyle(key, allThemes[key].colors));
  renderThemes();
  updateActiveControls();
  
  // --- TEMPLATE FUNCTIONS FOR FILE GENERATION --- //
  
  function generateCssContent() {
    let cssContent = `/*
 * This file is generated by the Widget Admin Dashboard.
 * It contains all the color themes for your widgets.
 */

:root {
  /* Default colors - used as a fallback */
  --primary-bg-color: #f4f7f6;
  --primary-text-color: #333333;
  --accent-color: #6a9a8d;
  --secondary-bg-color: #e0e6e4;
  --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}
`;
    for (const themeKey in allThemes) {
        const theme = allThemes[themeKey];
        cssContent += `
/* ${theme.name} */
.${theme.class} {
  --primary-bg-color: ${theme.colors[0]};
  --primary-text-color: ${theme.colors[1]};
  --accent-color: ${theme.colors[2]};
  --secondary-bg-color: ${theme.colors[3]};
}
`;
    }
    return cssContent;
  }

  function generateSettingsJsContent() {
    const themesObjectString = JSON.stringify(allThemes, null, 2);
    // This is a template of the entire settings.js file.
    // The current 'allThemes' object is injected into it.
    return `document.addEventListener('DOMContentLoaded', () => {
  // DOM Element References
  const themeControls = document.getElementById('theme-controls');
  const alignmentControls = document.getElementById('alignment-controls');
  const downloadConfigBtn = document.getElementById('download-config-btn');
  const downloadStylesBtn = document.getElementById('download-styles-btn');
  const updateInterfaceBtn = document.getElementById('update-interface-btn');
  const addThemeBtn = document.getElementById('add-theme-btn');
  const newThemeNameInput = document.getElementById('new-theme-name');
  const colorHexInputs = document.querySelectorAll('.color-hex-input');
  const colorPickers = document.querySelectorAll('input[type="color"]');
  const uploadInstructions = document.getElementById('upload-instructions');

  // Themes object - This is dynamically generated
  const allThemes = ${themesObjectString};

  // State object to track user selections
  let state = {
    selectedTheme: 'soft-evergreen-theme',
    selectedAlignment: 'center'
  };

  // --- FUNCTIONS --- //

  function updateActiveControls() {
    document.querySelectorAll('.theme-option').forEach(opt => opt.classList.toggle('active', opt.dataset.theme === state.selectedTheme));
    document.querySelectorAll('.alignment-option').forEach(opt => opt.classList.toggle('active', opt.dataset.alignment === state.selectedAlignment));
  }

  function createConfigFile() {
    const configContent = \`// Widget configuration file
// This file is generated by the Admin Dashboard.
const widgetConfig = {
  theme: '\${state.selectedTheme}',
  alignment: '\${state.selectedAlignment}'
};\`;
    triggerDownload(configContent, 'config.js', 'text/javascript');
    downloadConfigBtn.classList.add('clicked');
  }

  function downloadStylesFile() {
      const cssContent = generateCssContent();
      triggerDownload(cssContent, 'styles.css', 'text/css');
      downloadStylesBtn.classList.add('clicked');
  }

  function downloadSettingsJsFile() {
      const settingsJsContent = generateSettingsJsContent();
      triggerDownload(settingsJsContent, 'settings.js', 'text/javascript');
      updateInterfaceBtn.classList.add('clicked');
  }

  function triggerDownload(content, fileName, mimeType) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function addThemeStyle(themeKey, colors) {
    const style = document.createElement('style');
    style.id = \`style-\${themeKey}\`;
    style.innerHTML = \`.\${themeKey}{--primary-bg-color:\${colors[0]};--primary-text-color:\${colors[1]};--accent-color:\${colors[2]};--secondary-bg-color:\${colors[3]};}\`;
    document.head.appendChild(style);
  }
  
  function showSaveAndUploadElements() {
      downloadStylesBtn.style.display = 'inline-block';
      updateInterfaceBtn.style.display = 'inline-block';
      uploadInstructions.style.display = 'block';
      downloadStylesBtn.classList.remove('clicked');
      updateInterfaceBtn.classList.remove('clicked');
  }

  function renderThemes() {
    themeControls.innerHTML = '';
    for (const themeKey in allThemes) {
      const theme = allThemes[themeKey];
      const option = document.createElement('div');
      option.className = 'theme-option';
      option.dataset.theme = theme.class;
      option.innerHTML = \`<div class="color-swatch" style="background-color: \${theme.colors[0]};"></div><span>\${theme.name}</span>\${!theme.isDefault ? \`<button class="delete-btn" data-theme-key="\${themeKey}">×</button>\` : ''}\`;
      option.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-btn')) return;
        state.selectedTheme = option.dataset.theme;
        downloadConfigBtn.classList.remove('clicked');
        updateActiveControls();
      });
      themeControls.appendChild(option);
    }
    document.querySelectorAll('.delete-btn').forEach(btn => btn.addEventListener('click', deleteTheme));
    updateActiveControls();
  }

  function addNewTheme() {
    const themeName = newThemeNameInput.value.trim();
    if (!themeName) { alert('Please enter a theme name.'); return; }
    const themeKey = themeName.toLowerCase().replace(/\\s+/g, '-') + '-theme';
    if (allThemes[themeKey]) { alert('A theme with this name already exists.'); return; }
    const colors = [
        document.getElementById('color-primary-bg').value,
        document.getElementById('color-primary-text').value,
        document.getElementById('color-accent').value,
        document.getElementById('color-secondary-bg').value
    ];
    allThemes[themeKey] = { name: themeName, class: themeKey, colors: colors, isDefault: false };
    addThemeStyle(themeKey, colors);
    renderThemes();
    newThemeNameInput.value = '';
    showSaveAndUploadElements();
  }

  function deleteTheme(event) {
    const themeKey = event.target.dataset.themeKey;
    if (allThemes[themeKey]) {
        const styleTag = document.getElementById(\`style-\${themeKey}\`);
        if (styleTag) styleTag.remove();
        delete allThemes[themeKey];
        if (state.selectedTheme === themeKey) { state.selectedTheme = Object.keys(allThemes)[0]; }
        renderThemes();
        showSaveAndUploadElements();
    }
  }

  // --- EVENT LISTENERS & INITIALIZATION --- //

  downloadConfigBtn.addEventListener('click', createConfigFile);
  downloadStylesBtn.addEventListener('click', downloadStylesFile);
  updateInterfaceBtn.addEventListener('click', downloadSettingsJsFile);
  addThemeBtn.addEventListener('click', addNewTheme);
  
  alignmentControls.querySelectorAll('.alignment-option').forEach(option => {
    option.addEventListener('click', () => { 
        state.selectedAlignment = option.dataset.alignment; 
        downloadConfigBtn.classList.remove('clicked');
        updateActiveControls(); 
    });
  });
  
  colorPickers.forEach(picker => picker.addEventListener('input', (e) => { document.querySelector(\`.color-hex-input[data-picker="\${e.target.id}"]\`).value = e.target.value; }));
  colorHexInputs.forEach(input => input.addEventListener('input', (e) => { document.getElementById(e.target.dataset.picker).value = e.target.value; }));

  Object.keys(allThemes).forEach(key => addThemeStyle(key, allThemes[key].colors));
  renderThemes();
  updateActiveControls();
  
  // --- TEMPLATE FUNCTIONS FOR FILE GENERATION --- //
  
  function generateCssContent() {
    let cssContent = \`/*
 * This file is generated by the Widget Admin Dashboard.
 * It contains all the color themes for your widgets.
 */

:root {
  /* Default colors - used as a fallback */
  --primary-bg-color: #f4f7f6;
  --primary-text-color: #333333;
  --accent-color: #6a9a8d;
  --secondary-bg-color: #e0e6e4;
  --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}
\`;
    for (const themeKey in allThemes) {
        const theme = allThemes[themeKey];
        cssContent += \`
/* \${theme.name} */
.\${theme.class} {
  --primary-bg-color: \${theme.colors[0]};
  --primary-text-color: \${theme.colors[1]};
  --accent-color: \${theme.colors[2]};
  --secondary-bg-color: \${theme.colors[3]};
}
\`;
    }
    return cssContent;
  }

  function generateSettingsJsContent() {
    const themesObjectString = JSON.stringify(allThemes, null, 2);
    // This function is self-replicating. It's already defined above and will be included in the output.
    // We return the template that includes this very function.
    return \`\${arguments.callee.toString()}\`;
  }
});\`;
  }
});`;
  }
});